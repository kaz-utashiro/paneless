load_input_streams()
{
sources=$#

source_index=-1

for fd in "$@"
	do
		((source_index++))
		
		source_name="source$source_index" 
		source_names+=($source_name)
		source_source+=($fd)
		
		readarray $source_name < <(expand --tabs="$tab_size" $fd)
	done

# format pane contents
start_character=0 ; create_panes

# display lines and wait for commands

echo -en '\e[?1049h\e[2J' ; stty -echo ; tput civis
top_line=0 ; list ;
}

list()
{
LINES=$(tput lines)

((bottom_line = $LINES - status_line))

for((line = 1, pline = top_line ; line <= bottom_line ; line++, pline++))
	do
		(( pline < ${#lines[@]} )) &&
			{ echo -en "\e[$line;0H\e[K" ; echo -n "${lines[pline]}" ; } ||
			echo -en "\e[$line;0H\e[K$continuation_glyph"
	done

update_status

((overlay_line_number == 1)) && echo -en "\e[H$MAGENTA[$((top_line + 1))$overlay_line_total]$RESET"
((overlay_line_number == 2)) && echo -en "\e[$bottom_line;0H$MAGENTA[$((top_line + bottom_line))$overlay_line_total]$RESET"
}

update_status() { ((status_line)) && echo -en "\e[$((bottom_line + 2));0H\e[K" ; }

create_panes()
{
((pane_columns = (COLS / sources) - 1))

separator="$(echo "$PANELESS_GLYPHâ”‚$RESET")"
continuation_glyph="$(echo "$PANELESS_GLYPH~$RESET")"
padding="$continuation_glyph$(perl -e 'print " " x ($ARGV[0] - 1)' $pane_columns)"

((end_padding = (COLS - ((pane_columns +1)  * sources) ) + 1))
end_padding="$(perl -e 'print " " x $ARGV[0]' $end_padding)"

lines=()
line_blocks=()
current_color=0

# format input streams to fit panes
source_index=-1
for source_name in "${source_names[@]}"
	do
		((no_color)) && color= ||
			{
			color=${colors[current_color]}
			((current_color++, current_color >= ${#colors[@]})) && current_color=0
			}
		
		((source_index++))
		declare -n source_ref="$source_name"
		
		array_name="lines$source_index" 
		line_blocks+=($array_name)
		
		declare -n source_ref="$source_name"
		
		readarray -t $array_name < \
			<(\
			printf "%s" "${source_ref[@]}" | \
			{
			((ansi)) \
				&& perl -pe 'BEGIN{ use Text::ANSI::WideUtil qw( ta_mbsubstr ) ; use open qw(:std :utf8); } ; chomp ; $_ = "'$color'" . ta_mbsubstr($_ . (" " x 200), '$start_character', '$pane_columns') . "'$RESET'\n"' \
				|| perl -pe 'BEGIN{ use open qw(:std :utf8); } ; chomp ; $_ = "'$color'" . substr($_ . (" " x 200), '$start_character', '$pane_columns') . "'$RESET'\n"'
			}
			)
		
		declare -n array_ref="$array_name"
		((max_lines < ${#array_ref[@]})) && max_lines=${#array_ref[@]}
		
	done

# join formatted input
for((line=0 ; line < max_lines ; line++))
	do
		source_index=-1
		for array_name in ${line_blocks[@]}
			do
				((source_index++))
				((source_index)) && col_separator="$separator" || col_separator=
				
				declare -n array_ref="$array_name"
				((line < ${#array_ref[@]})) && new_pane="${array_ref[line]}" || new_pane="$padding"
				
				lines[$line]+="$col_separator$new_pane"
			done
		
		lines[$line]+="$end_padding"
	done
printf "%s\n" "${lines[@]}" >"$serialized_panes"
}

reload() { source_names=() ; line_blocks=() ; lines=() ; load_input_streams "${ARGV[@]}"  ; }

geo_winch() { geometry ; WCOLS=$COLS ; WLINES=$LINES ; }
geometry()  { { read LINES ; read COLS ; } < <(tput lines cols) ; }
winch()     { ((winch)) || return ; geometry ; ((WCOLS != COLS)) && { create_panes ; list ; true ; } || ((WLINES != LINES)) && list ; WCOLS=$COLS ; WLINES=$LINES ; }

pdhn()      { echo "$@" ; read -sn1 ; }
try()       { exec 9>&2 2>"$fs/log" ; "$@" ; exec 2>&9 ; [[ -s $fs/log ]] && try_errorp ; }
try_error() { echo "echo -ne '\e[2J\e[H\e[31m' ; cat $fs/log | tee -a $fs/errors_log && rm $fs/log" ; }
try_errorp(){ pdhn  "$(cat $fs/log)" ; tmux popup -w 80% "$(try_error)" ; }

prompt()    { exec 2>&9 ; stty echo ; echo -ne "\e[H\e[K$MAGENTA\e[?25h" ; read -e -rp "$@" ; echo -ne '\e[m' ; stty -echo ; tput civis ; exec 2>"$fs/log" ; }

# core setup

fs="$(mktemp -u -p /tmp/$USER paneless_XXXXXX)" ; mkdir -p $fs # work directory
serialized_panes="$fs/serialized_panes"

geo_winch   # save terminal size

# vim: set filetype=bash:
