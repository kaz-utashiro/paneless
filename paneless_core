load_input_streams()
{
sources=$#

source_index=-1

for fd in "$@"
	do
		((source_index++))
		
		source_name="source$source_index" 
		source_names+=($source_name)
		source_source+=($fd)
		
		readarray $source_name < <(expand --tabs="$tab_size" $fd)
	done

# format pane contents
start_character=0 ; create_panes

# display panes and wait for commands

echo -en '\e[?1049h\e[2J' ; stty -echo ; tput civis
top_line=0 ; list ;
}

list()
{
echo -en "\e[H"
LINES=$(tput lines)

((bottom_line = top_line + $LINES -1))

for((line=$top_line ; line <= bottom_line ; line++))
	do
		((line == top_line)) && 
			{
			# ((highlight)) && 
			# 	{ echo "${panes[line]}" | rg "$search_string" ; highlight= ; } ||
				echo -n "${panes[line]}"
			} ||
			echo -n "${panes[line]}"
		((line != bottom_line)) && echo
	done

((overlay_line_number == 1)) && echo -en "\e[H$MAGENTA[$top_line]$RESET"
((overlay_line_number == 2)) && echo -en "\r$MAGENTA[$((top_line + LINES))]$RESET"
}

create_panes()
{
((pane_columns = (COLS / sources) - 1))

separator="$(echo "$PANELESS_GLYPHâ”‚$RESET")"
continuation_glyph="$(echo "$PANELESS_GLYPH~$RESET")"
padding="$continuation_glyph$(perl -e 'print " " x ($ARGV[0] - 1)' $pane_columns)"

((end_padding = (COLS - ((pane_columns +1)  * sources) ) + 1))
end_padding="$(perl -e 'print " " x $ARGV[0]' $end_padding)"

panes=()
line_blocks=()
current_color=0

# format input streams to fit panes
source_index=-1
for source_name in "${source_names[@]}"
	do
		((no_color)) && color= ||
			{
			color=${colors[current_color]}
			((current_color++, current_color >= ${#colors[@]})) && current_color=0
			}
		
		((source_index++))
		declare -n source_ref="$source_name"
		
		array_name="lines$source_index" 
		line_blocks+=($array_name)
		
		declare -n source_ref="$source_name"
		
		readarray -t $array_name < \
			<(\
			printf "%s" "${source_ref[@]}" | \
			{
			((ansi)) \
				&& perl -pe 'BEGIN{ use Text::ANSI::WideUtil qw( ta_mbsubstr ) ; use open qw(:std :utf8); } ; chomp ; $_ = "'$color'" . ta_mbsubstr($_ . (" " x 200), '$start_character', '$pane_columns') . "'$RESET'\n"' \
				|| perl -pe 'BEGIN{ use open qw(:std :utf8); } ; chomp ; $_ = "'$color'" . substr($_ . (" " x 200), '$start_character', '$pane_columns') . "'$RESET'\n"'
			}
			)
		
		declare -n array_ref="$array_name"
		((max_lines < ${#array_ref[@]})) && max_lines=${#array_ref[@]}
		
	done

# join formatted input
for((line=0 ; line < max_lines ; line++))
	do
		source_index=-1
		for array_name in ${line_blocks[@]}
			do
				((source_index++))
				((source_index)) && col_separator="$separator" || col_separator=
				
				declare -n array_ref="$array_name"
				((line < ${#array_ref[@]})) && new_pane="${array_ref[line]}" || new_pane="$padding"
				
				panes[$line]+="$col_separator$new_pane"
			done
		
		panes[$line]+="$end_padding"
	done

for((line = max_lines ; line <= max_lines + LINES; line++))
	do
	panes[line]="$continuation_glyph"$'\e[K'
	done

printf "%s\n" "${panes[@]}" >"$serialized_panes"
}

reload() { source_names=() ; line_blocks=() ; panes=() ; load_input_streams "${ARGV[@]}"  ; }

geo_winch() { geometry ; WCOLS=$COLS ; WLINES=$LINES ; }
geometry()  { { read LINES ; read COLS ; } < <(tput lines cols) ; }
winch()     { ((winch)) || return ; geometry ; ((WCOLS != COLS)) && { create_panes ; list ; true ; } || ((WLINES != LINES)) && list ; WCOLS=$COLS ; WLINES=$LINES ; }

pdhn()      { echo "$@" ; read -sn1 ; }
try()       { exec 9>&2 2>"$fs/log" ; "$@" ; exec 2>&9 ; [[ -s $fs/log ]] && try_errorp ; }
try_error() { echo "echo -ne '\e[2J\e[H\e[31m' ; cat $fs/log | tee -a $fs/errors_log && rm $fs/log" ; }
try_errorp(){ pdhn  "$(cat $fs/log)" ; tmux popup -w 80% "$(try_error)" ; }

prompt()    { exec 2>&9 ; stty echo ; echo -ne "\e[H\e[K$MAGENTA\e[?25h" ; read -e -rp "$@" ; echo -ne '\e[m' ; stty -echo ; tput civis ; exec 2>"$fs/log" ; }

# core setup

fs="$(mktemp -u -p /tmp/$USER paneless_XXXXXX)" ; mkdir -p $fs # work directory
serialized_panes="$fs/serialized_panes"

geo_winch   # save terminal size

# vim: set filetype=bash:
