load_input_streams()
{
sources=$#

source_index=-1

for fd in "$@"
	do
		((source_index++))
		
		source_name="source$source_index" 
		source_names+=($source_name)
		source_source+=($fd)
		
		readarray $source_name < <(expand --tabs="$tab_size" $fd)
	done

# format pane contents
start_character=0 ; create_panes

# display lines and wait for commands

echo -en '\e[?1049h\e[2J' ; stty -echo ; tput civis
top_line=0 ; list ;
}

list()
{
LINES=$(tput lines)

((bottom_line = $LINES - status_line))

for((line = 1, pline = top_line ; line <= bottom_line ; line++, pline++))
	do
		(( pline < ${#lines[@]} )) &&
			{
			((${#custom_column[@]} == 0)) && { echo -en "\e[$line;0H\e[K" ; echo -n "${lines[pline]}" ; } ||
				{
				current_line= source_index=-1
				 
				for array_name in ${line_blocks[@]}
					do
						((source_index++))
						
						((custom_column[$source_index] == 1)) && { get_pane_text pane_text $top_line $line $pline $source_index $array_name ; } ||
							{
							declare -n array_ref="$array_name"
							((pline < ${#array_ref[@]})) && pane_text="${array_ref[pline]}" || pane_text="${padding[source_index]}"
							}
						
						current_line+="$pane_text$separator"
					done
				
				echo -en "\e[$line;0H\e[K" ; echo -n "$current_line$end_padding" ;
				}
			} || echo -en "\e[$line;0H\e[K$continuation_glyph"
	done

update_status

((overlay_line_number == 1)) && echo -en "\e[H$MAGENTA[$((top_line + 1))$overlay_line_total]$RESET"
((overlay_line_number == 2)) && echo -en "\e[$bottom_line;0H$MAGENTA[$((top_line + bottom_line))$overlay_line_total]$RESET"

overlay_text
}

get_pane_text()
{
echo "paneless: calling default get_pane_text makes little sense" ; quit_no_clear

# local text_ref=$1 top_line="$2" line="$3" pline="$4" source_index="$5" array_name="$6"

# declare -n text="$text_ref"
# declare -n array_ref="$array_name"
# ((pline < ${#array_ref[@]})) && text="${array_ref[pline]}" || text="${padding[source_index]}"
}

overlay_text() {  : ; }

update_status() { ((status_line)) && echo -en "\e[$((bottom_line + 2));0H\e[K" ; }

create_panes()
{
((remaining_cols = COLS, remaining_perc = 100, sharing_panes = sources))
pane_columns=()

for w in "${widths[@]}"
	do
		if   [[ "$w" =~ [[:digit:]][[:digit:]]$  ]]
			then { ((wt = w + 1)) ; pane_columns+=($wt) ; ((sharing_panes-- , remaining_cols -= wt, remaining_cols >= 0)) || { echo "paneless: can't fit $w" && exit 1 ; } ; }
		elif [[ "$w" =~ [[:digit:]][[:digit:]]\%$ ]]
			then { pane_columns+=($w) ; ((sharing_panes-- , remaining_perc -= ${w:0:-1} , remaining_perc >= 0)) || { echo "paneless: can't fit $w" && exit 1 ; } ; }
		else pane_columns+=('')
		fi
	done

((sharing_panes > 0)) && 
	{
	((pane_share = ( (remaining_cols * remaining_perc) / (sharing_panes * 100) ) - 1)) || pane_share=0
	((pane_share <= 0)) && { echo "paneless: not enought room" ; exit 1 ; }
	}

for ((source_index = 0 ;  source_index < $sources ; source_index++))
	do
		[[ "${pane_columns[source_index]}" ]] &&
			{
			[[ "${pane_columns[source_index]}" =~ [[:digit:]][[:digit:]]% ]] &&
				(( pane_columns[source_index] = remaining_cols * ${pane_columns[source_index]:0:-1}  / 100 ))
			
			true
			} ||
			{
			((pane_columns[source_index] = $pane_share))
			}
	done

separator=$"$PANELESS_GLYPHâ”‚$RESET"
continuation_glyph=$"$PANELESS_GLYPH~$RESET"

lines=()
line_blocks=()
current_color=0

# format input streams to fit panes
source_index=-1
for source_name in "${source_names[@]}"
	do
		((no_color)) && color= ||
			{
			color=${colors[current_color]}
			((current_color++, current_color >= ${#colors[@]})) && current_color=0
			}
		
		((source_index++))
		declare -n source_ref="$source_name"
		
		array_name="lines$source_index" 
		line_blocks+=($array_name)
		
		declare -n source_ref="$source_name"
		
		readarray -t $array_name < \
			<(\
			printf "%s" "${source_ref[@]}" | \
			{
			((text_length = pane_columns[source_index] - 1))
			
			((ansi)) \
				&& perl -pe 'BEGIN{ use Text::ANSI::WideUtil qw( ta_mbsubstr ) ; use open qw(:std :utf8); } ; chomp ; $_ = "'$color'" . ta_mbsubstr($_ . (" " x 200), '$start_character', '$text_length') . "'$RESET'\n"' \
				|| perl -pe 'BEGIN{ use open qw(:std :utf8); } ; chomp ; $_ = "'$color'" . substr($_ . (" " x 200), '$start_character', '$text_length') . "'$RESET'\n"'
			}
			)
		
		declare -n array_ref="$array_name"
		((max_lines < ${#array_ref[@]})) && max_lines=${#array_ref[@]}
		
	done

used_columns=0

for ((source_index = 0 ;  source_index < $sources ; source_index++))
	do
		padding[source_index]="$continuation_glyph$(perl -e 'print " " x ($ARGV[0] - 2)' "${pane_columns[source_index]}")"
		
		((used_columns += pane_columns[source_index]))
	done

end_padding="$(perl -e 'print " " x $ARGV[0]' $((COLS - used_columns)))"

# join formatted input
for((line=0 ; line < max_lines ; line++))
	do
		source_index=-1
		for array_name in ${line_blocks[@]}
			do
				((source_index++))
				
				declare -n array_ref="$array_name"
				((line < ${#array_ref[@]})) && pane_text="${array_ref[line]}" || pane_text="${padding[source_index]}"
				
				lines[$line]+="$pane_text$separator"
			done
		
		lines[$line]+="$end_padding"
	done

printf "%s\n" "${lines[@]}" >"$serialized_panes"
}

reload() { source_names=() ; line_blocks=() ; lines=() ; load_input_streams "${ARGV[@]}"  ; }

geo_winch() { geometry ; WCOLS=$COLS ; WLINES=$LINES ; }
geometry()  { { read LINES ; read COLS ; } < <(tput lines cols) ; }
winch()     { ((winch)) || return ; geometry ; ((WCOLS != COLS)) && { create_panes ; list ; true ; } || ((WLINES != LINES)) && list ; WCOLS=$COLS ; WLINES=$LINES ; }

pdhn()      { echo "$@" ; read -sn1 ; }
try()       { exec 9>&2 2>"$fs/log" ; "$@" ; exec 2>&9 ; [[ -s $fs/log ]] && try_errorp ; }
try_error() { echo "echo -ne '\e[2J\e[H\e[31m' ; cat $fs/log | tee -a $fs/errors_log && rm $fs/log" ; }
try_errorp(){ pdhn  "$(cat $fs/log)" ; tmux popup -w 80% "$(try_error)" ; }

prompt()    { exec 2>&9 ; stty echo ; echo -ne "\e[H\e[K$MAGENTA\e[?25h" ; read -e -rp "$@" ; echo -ne '\e[m' ; stty -echo ; tput civis ; exec 2>"$fs/log" ; }

# core setup

fs="$(mktemp -u -p /tmp/$USER paneless_XXXXXX)" ; mkdir -p $fs # work directory
serialized_panes="$fs/serialized_panes"

geo_winch   # save terminal size

# vim: set filetype=bash:
